# ScotlandYardGame
Created for Object Oriented Programming unit from University of Bristol with collaboration with Yau Sze Ying 
https://www.ole.bris.ac.uk/bbcswebdav/courses/COMS10009_2018/content/model/index.html


Scotland Yard Model 

The project started by creating the essential fields of the model. Consequently, the implementation of the constructor of the model followed. Inside the parameterized constructor, which initializes a newly created ScotlandYardModel object, it was necessary to ensure and check that all the information passed by its parameters, following the rules and restrictions of the game (e.g. not null rounds[] and graph, not two players with the same location or colour, etc.). Lastly, all the provided players information was stored in a list that is mutable in order to access and modify its player’s information during the game.
Subsequently, the methods of the ScotlandYardView interface were implemented so that the respective information about the game and its players could be accessed. Following the implementation guide, it was ensured to return an immutable collection for the methods that returned information that couldn’t be changed after their creation (like getRounds(), getPlayers(), etc.). Then for getCurrentPlayer(), getCurrentRound() and getPlayerLocation(), necessary fields were created to keep track of each of this information. For getPlayerLocation(), Mr. X’s last known location had to be maintained, so a field was created dedicated to this information called blackLatestLocation.
Next, the startRotate() method was implemented so that it is possible to start cycling through all the moves of the game. StartRotate() starts from the first player, Mr. X, generates his valid moves according to his location and tickets and notifies the player to choose his move by calling the makeMove() method. After the player chooses their move, the model calls the accept method, in order to accept the move that the player chose as well as, play it out. The accept method, makes sure that the chosen move is not null and is a valid move. After that, the current player advances to the next one and the visitor pattern is used to deal with the three kinds of moves the player might choose (i.e. PassMove, TicketMove and DoubleMove) in order to actually play the move (update player’s location and tickets in hand), possibly advance to the next round and notify the spectators along the way (about the move made, the start of a round and/or the completion of a rotation). In order to generate the valid moves of a player, the validMove() method was created. For a move to be valid, the player has to have enough of the type of ticket used for the potential valid move and the destination of that move has to be unoccupied. To check this we created two auxiliary methods, adequateTickets() and locationFree(). Using these two methods validMove() finds all the different moves that the player could possibly do, checking specifically for single moves using normal tickets (if player is detective) and on top of that for secret and double moves (if player is Mr. X).
